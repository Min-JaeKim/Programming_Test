# python

## baek 3649 로봇 프로젝트 골드4

https://www.acmicpc.net/problem/3649

> python3 5420ms

* 문제

  > 상근이와 선영이는 학교 숙제로 로봇을 만들고 있다. 로봇을 만들던 중에 구멍을 막을 두 레고 조각이 필요하다는 것을 깨달았다.
  >
  > 구멍의 너비는 x 센티미터이고, 구멍에 넣을 두 조각의 길이의 합은 구멍의 너비와 정확하게 일치해야 한다. 정확하게 일치하지 않으면, 프로젝트 시연을 할 때 로봇은 부수어질 것이고 상근이와 선영이는 F를 받게 된다. 구멍은 항상 두 조각으로 막아야 한다.
  >
  > 지난밤, 상근이와 선영이는 물리 실험실에 들어가서 레고 조각의 크기를 모두 정확하게 재고 돌아왔다. 구멍을 완벽하게 막을 수 있는 두 조각을 구하는 프로그램을 작성하시오.

* 입력

  > 입력은 여러 개의 테스트 케이스로 이루어져 있다.
  >
  > 각 테스트 케이스의 첫째 줄에는 구멍의 너비 x (1 ≤ x ≤ 20, x는 정수)가 주어진다. x의 단위는 센티미터이다.
  >
  > 다음 줄에는 물리 실험실에 있는 레고 조각의 수 n이 주어진다. (0 ≤ n ≤ 1000000)
  >
  > 다음 n개의 줄에는 레고 조각의 길이 ℓ이 주어진다. ℓ은 양의 정수이며, 단위는 나노미터이다. 블록의 길이는 10 센티미터 (100000000 나노미터)를 넘지 않는다.
  >
  > ```bash
  > 1
  > 4
  > 9999998
  > 1
  > 2
  > 9999999
  > ```
  >
  
* 출력

  > 각 테스트 케이스마다 한 줄에 하나씩, 구멍을 완벽하게 막을 수 있는 두 조각이 없다면 'danger'를 출력한다. 막을 수 있는 경우에는 'yes ℓ1 ℓ2'를 출력한다. (ℓ1 ≤ ℓ2)
  >
  > 정답이 여러 개인 경우에는 |ℓ1 - ℓ2|가 가장 큰 것을 출력한다.
  >
  > ```bash
  > yes 1 9999999
  > ```



- 

```python
import sys
input = sys.stdin.readline


def sol():

    while 1:
        try:
            x = int(input()) * 10000000
            n = int(input())
            arr = [int(input()) for _ in range(n)]
            arr.sort()

            left, right, flag = 0, n-1, False

            while left < right:
                if arr[left] + arr[right] > x:
                    right -= 1
                elif arr[left] + arr[right] < x:
                    left += 1
                else:
                    print('yes', end=' ')
                    print(arr[left], arr[right])
                    flag = True
                    break

            if not flag:
                print('danger')

        except:
            exit()


sol()
```

> 처음에 생각했던 방법인데, 문제에서 은근하게 답이 여러 개 될 수 있다고 흘려 줘서 이렇게 풀면 안되는 건가 했다. 그래서 for문으로 left를 매번 변경해 주며 또 하나의 레고를 찾기 위해 이분탐색을 해줬는데 시간초과남. 이때 답은 하나일 수 밖에 없다고 느꼈고(왜냐면 절댓값이 가장 크려면 작은값이 제일 작은값이어야 한다.) 투포인터를 다시 쓸 수 있었다.



* 모범답안

  ```python
  
  ```

  > 내가 3등! 다른 풀이 다 비슷

